#include "vex.h"
#include <vex_triport.h>

using namespace vex;
using namespace std;

const long double PI = 3.14159265358979323846264338328;

competition Competition;

controller Controller;

//Drive Motors
motor fLeft = motor(PORT12, false);
motor bLeft = motor(PORT11, false);
motor fRight = motor(PORT19, true);
motor bRight = motor(PORT20, true);

//Three Wire Sensors
encoder lEncoder = encoder(Brain.ThreeWirePort.C);
encoder rEncoder = encoder(Brain.ThreeWirePort.A);
encoder bEncoder = encoder(Brain.ThreeWirePort.E);


/*
*
*   Stop/Reset Functions
*
*/

//Stops drive
void brakeDrive()
{
  fLeft.stop(vex::brakeType::brake);
  bLeft.stop(vex::brakeType::brake);
  fRight.stop(vex::brakeType::brake);
  bRight.stop(vex::brakeType::brake);
}

//Drive coasts to a stop
void coastDrive()
{
  fLeft.stop(vex::brakeType::coast);
  bLeft.stop(vex::brakeType::coast);
  fRight.stop(vex::brakeType::coast);
  bRight.stop(vex::brakeType::coast);
}

void resetEncoders()
{
  lEncoder.resetRotation();
  rEncoder.resetRotation();
  bEncoder.resetRotation();
}

/*
*
*   Driver Functions
*
*/

void manualDriveControl()
{
  if((abs(Controller.Axis4.value()) > 10) || (abs(Controller.Axis3.value()) > 10))
  {
    int leftSideValue = Controller.Axis3.value() - Controller.Axis4.value();
    leftSideValue = .001*pow(leftSideValue,3);
    int rightSideValue = Controller.Axis3.value() + Controller.Axis4.value();
    rightSideValue = .001*pow(rightSideValue,3);

    fLeft.spin(directionType::fwd, leftSideValue, velocityUnits::pct);
    bLeft.spin(directionType::fwd, leftSideValue, velocityUnits::pct);
    fRight.spin(directionType::fwd, leftSideValue, velocityUnits::pct);
    bRight.spin(directionType::fwd, leftSideValue, velocityUnits::pct);
  }
  else
  {
    coastDrive();
  }
}

/*
*
*   Odom Control
*
*/

bool enableOdom = true;

double sL = 0; //Left-right distance from the tracking center to the left tracking wheel
double sR = 0; //Left-right distance from the tracking center to the right tracking wheel
double sS = 0; //Forward-backward distance from the tracking center to the back tracking wheel
double d0 = 0; //Previous global position vector

double theta0 = 0; //Previous global orientation
double theta1 = 0; //Absolute orientation
double thetaR = 0; //Global orientation at last reset
double dTheta = 0; //Change in angle

double lEnc = 0;
double rEnc = 0;
double bEnc = 0;
double prevLEnc = 0;
double prevREnc = 0;
double prevBEnc = 0;
double dLEnc = 0;
double dREnc = 0;
double dBEnc = 0;

double dLr = 0;
double dRr = 0;

double dL = 0;
double dR = 0;
double dB = 0;

int odomControl()
{
  while(enableOdom)
  {
    //Store current encoder values in local variables
    lEnc = lEncoder.rotation(deg); //Encoder value for the left tracking wheel
    rEnc = rEncoder.rotation(deg); //Encoder value for the rigt tracking wheel
    bEnc = bEncoder.rotation(deg); //Encoder value for the back tracking wheel

    //Calculate change in each encoders' value since last cycle
    dLEnc = lEnc - prevLEnc; //Change in left tracking wheel rotation
    dREnc = rEnc - prevREnc; //Change in right tracking wheel rotation
    dBEnc = bEnc - prevBEnc; //Change in back tracking wheel rotation

    //Convert change in value to distance
    dL = 1.375 * 2 * PI * (dLEnc / 360);
    dR = 1.375 * 2 * PI * (dREnc / 360);
    dB = 1.375 * 2 * PI * (dBEnc / 360);

    //Update previous values of encoders
    prevLEnc = lEnc; //Current left encoder value becomes previous value
    prevREnc = rEnc; //Current right encoder value becomes previous value
    prevBEnc = bEnc; //Curent back encoder value becomes previous value

    //Calculate total change of left and right encoder values since last reset
    dLr += dLEnc;
    dRr += dREnc;

    //Calculate new absolute orientation
    theta1 = thetaR + ((dLr - dRr)/(sL + sR))*(180/PI);

    //Calculate change in angle
    dTheta = theta1 - theta0;

    //If dL = dR, then calculate local offset
    if(dTheta == 0)
    {
      
    }

  }
  return 1;
}

/*
*
*   Main Functions
*
*/

void pre_auton()
{
  brakeDrive();

}

void usercontrol(void)
{
  manualDriveControl();
}

void auton(void)
{

}

int main() 
{
  Competition.autonomous(auton);
  Competition.drivercontrol(usercontrol);

  while(true)
  {
    vex::task::sleep(1);
  }
}
